<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>algorithms</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <style>
    html {
      font-size: 100%;
      overflow-y: scroll;
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
    }
    body {
      color: #444;
      font-family: Georgia, Palatino, "Palatino Linotype", Times,
        "Times New Roman", serif;
      font-size: 12px;
      line-height: 1.7;
      padding: 1em;
      margin: auto;
      max-width: 42em;
      background: #fefefe;
    }
    a {
      color: #0645ad;
      text-decoration: none;
    }
    a:visited {
      color: #0b0080;
    }
    a:hover {
      color: #06e;
    }
    a:active {
      color: #faa700;
    }
    a:focus {
      outline: thin dotted;
    }
    ::-moz-selection {
      background: rgba(255, 255, 0, 0.3);
      color: #000;
    }
    ::selection {
      background: rgba(255, 255, 0, 0.3);
      color: #000;
    }
    a::-moz-selection {
      background: rgba(255, 255, 0, 0.3);
      color: #0645ad;
    }
    a::selection {
      background: rgba(255, 255, 0, 0.3);
      color: #0645ad;
    }
    p {
      margin: 1em 0;
    }
    img {
      max-width: 100%;
    }
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      color: #111;
      line-height: 125%;
      margin-top: 2em;
      font-weight: 400;
    }
    h4,
    h5,
    h6 {
      font-weight: 700;
    }
    h1 {
      font-size: 2.5em;
    }
    h2 {
      font-size: 2em;
    }
    h3 {
      font-size: 1.5em;
    }
    h4 {
      font-size: 1.2em;
    }
    h5 {
      font-size: 1em;
    }
    h6 {
      font-size: 0.9em;
    }
    blockquote {
      color: #666;
      margin: 0;
      padding-left: 3em;
      border-left: 0.5em #eee solid;
    }
    hr {
      display: block;
      height: 2px;
      border: 0;
      border-top: 1px solid #aaa;
      border-bottom: 1px solid #eee;
      margin: 1em 0;
      padding: 0;
    }
    code,
    kbd,
    pre,
    samp {
      color: #000;
      font-family: monospace, monospace;
      font-size: 0.98em;
    }
    pre {
      white-space: pre;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    b,
    strong {
      font-weight: 700;
    }
    dfn {
      font-style: italic;
    }
    ins {
      background: #ff9;
      color: #000;
      text-decoration: none;
    }
    mark {
      background: #ff0;
      color: #000;
      font-style: italic;
      font-weight: 700;
    }
    sub,
    sup {
      font-size: 75%;
      line-height: 0;
      position: relative;
      vertical-align: baseline;
    }
    sup {
      top: -0.5em;
    }
    sub {
      bottom: -0.25em;
    }
    ol,
    ul {
      margin: 1em 0;
      padding: 0 0 0 2em;
    }
    li p:last-child {
      margin-bottom: 0;
    }
    ol ol,
    ul ul {
      margin: 0.3em 0;
    }
    dl {
      margin-bottom: 1em;
    }
    dt {
      font-weight: 700;
      margin-bottom: 0.8em;
    }
    dd {
      margin: 0 0 0.8em 2em;
    }
    dd:last-child {
      margin-bottom: 0;
    }
    img {
      border: 0;
      -ms-interpolation-mode: bicubic;
      vertical-align: middle;
    }
    figure {
      display: block;
      text-align: center;
      margin: 1em 0;
    }
    figure img {
      border: none;
      margin: 0 auto;
    }
    figcaption {
      font-size: 0.8em;
      font-style: italic;
      margin: 0 0 0.8em;
    }
    table {
      margin-bottom: 2em;
      border-bottom: 1px solid #ddd;
      border-right: 1px solid #ddd;
      border-spacing: 0;
      border-collapse: collapse;
    }
    table th {
      padding: 0.2em 1em;
      background-color: #eee;
      border-top: 1px solid #ddd;
      border-left: 1px solid #ddd;
    }
    table td {
      padding: 0.2em 1em;
      border-top: 1px solid #ddd;
      border-left: 1px solid #ddd;
      vertical-align: top;
    }
    .author {
      font-size: 1.2em;
      text-align: center;
    }
    @media only screen and (min-width: 480px) {
      body {
        font-size: 14px;
      }
    }
    @media only screen and (min-width: 768px) {
      body {
        font-size: 16px;
      }
    }
    @media print {
      * {
        background: 0 0 !important;
        color: #000 !important;
        filter: none !important;
        -ms-filter: none !important;
      }
      body {
        font-size: 12pt;
        max-width: 100%;
      }
      a,
      a:visited {
        text-decoration: underline;
      }
      hr {
        height: 1px;
        border: 0;
        border-bottom: 1px solid #000;
      }
      a[href]:after {
        content: " (" attr(href) ")";
      }
      abbr[title]:after {
        content: " (" attr(title) ")";
      }
      .ir a:after,
      a[href^="#"]:after,
      a[href^="javascript:"]:after {
        content: "";
      }
      blockquote,
      pre {
        border: 1px solid #999;
        padding-right: 1em;
        page-break-inside: avoid;
      }
      img,
      tr {
        page-break-inside: avoid;
      }
      img {
        max-width: 100% !important;
      }
      @page :left {
        margin: 15mm 20mm 15mm 10mm;
      }
      @page :right {
        margin: 15mm 10mm 15mm 20mm;
      }
      h2,
      h3,
      p {
        orphans: 3;
        widows: 3;
      }
      h2,
      h3 {
        page-break-after: avoid;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/darkreader@4.7.15/darkreader.min.js"></script>
  <script>
    DarkReader.enable({
      brightness: 100,
      contrast: 90,
      sepia: 10
    });
  </script>
  <link
    rel="icon"
    type="image/png"
    href="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcTJg97A-Sa8mxjkRCmjR51WjHATLvq2aF89Z1CprR2WcQ60qYZC"
  />
  <meta name="theme-color" content="#252525" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 data-number="1" id="algorithms"><span
class="header-section-number">1</span> algorithms</h1>
<h2 data-number="1.1" id="decision-problem"><span
class="header-section-number">1.1</span> decision problem</h2>
<p>A decision problem is a problem for which the answer is YES or NO. It
can be defined as a finite set of parameters.</p>
<ul>
<li><span class="math inline">\Pi</span> - a decision problem</li>
<li><span class="math inline">D_\Pi</span> - set of instances of <span
class="math inline">\Pi</span></li>
<li><span class="math inline">Y_\Pi \subseteq D_\Pi</span> - the set of
YES instances</li>
<li><span class="math inline">\bar \Pi</span> - the complementary
problem to <span class="math inline">\Pi</span> (<span
class="math inline">D_{\bar\Pi} = D_\Pi</span>, <span
class="math inline">Y_{\bar\Pi} = D_{\Pi} \setminus Y_\Pi</span>)</li>
</ul>
<h3 data-number="1.1.1" id="instance-of-the-problem"><span
class="header-section-number">1.1.1</span> instance of the problem</h3>
<p>If we fix the values of the parameters we get an instance of the
problem.</p>
<h3 data-number="1.1.2" id="encoding"><span
class="header-section-number">1.1.2</span> encoding</h3>
<p>Encoding of a decision problem <span class="math inline">\Pi</span>
is a function <span class="math inline">e: D_\Pi \to \Sigma^*</span>
where <span class="math inline">\Sigma</span> is an alphabet. For a
decision problem <span class="math inline">\Pi</span> and an encoding
<span class="math inline">e</span> fo <span
class="math inline">\Pi</span> there is a corresponding language</p>
<p><span class="math display">
L(\Pi,e) = L_\Pi = \{e(I) \in \Sigma^* : I \in Y_\Pi\}
</span></p>
<p><span class="math inline">\Pi</span> is called decidable if <span
class="math inline">L_\Pi \in R</span> otherwise <span
class="math inline">\Pi</span> is called undecidable.</p>
<h4 data-number="1.1.2.1" id="reasonable-encodings"><span
class="header-section-number">1.1.2.1</span> reasonable encodings</h4>
<p>Example: encoding of natural number <span
class="math inline">n</span> on the tape of a TM:</p>
<ul>
<li><span class="math inline">\Sigma = \{0, 1\}</span> - reasonable
encoding (length of <span class="math inline">\log n</span>)</li>
<li><span class="math inline">\Sigma = \{0, 1, \cdots, 9\}</span> -
reasonable encoding (length of <span class="math inline">\log_{10}
n</span>)</li>
<li><span class="math inline">\Sigma = \{1\}</span> - not reasonable
encoding (length of <span class="math inline">n</span>)</li>
</ul>
<p>subjective</p>
<h3 data-number="1.1.3" id="post-correspondence-problem-pcp"><span
class="header-section-number">1.1.3</span> post correspondence problem
(PCP)</h3>
<p>Instance: two lists <span class="math inline">A = w_1, w_2, \cdots,
w_k</span> and <span class="math inline">B = x_1, x_2, \cdots,
x_k</span> of strings over <span class="math inline">\Sigma</span>. A
solution is a finite sequence of indices <span class="math inline">i_1,
i_2, \cdots, i_m</span> <span class="math inline">m \ge 1</span> such
that <span class="math inline">w_{i_1} \circ w_{i_2} \circ \cdots \circ
w_{i_m} = x_{i_1} \circ x_{i_2} \circ \cdots \circ x_{i_m}</span></p>
<h3 data-number="1.1.4"
id="modified-post-correspondence-problem-mpcp"><span
class="header-section-number">1.1.4</span> modified post correspondence
problem (MPCP)</h3>
<p>It is the standard PCP but with the condition that <span
class="math inline">i_1 = 1</span></p>
<p><strong>lemma</strong>: if PCP is decidable then MPCP is
decidable.</p>
<p>If there exists an algorithm for solving PCP then there exists an
algorithm for solving MPCP.</p>
<p><strong>theorem</strong>: PCP is undecidable. By lemma it suffices to
show that if MPCP is decidable then <span class="math inline">L_u \in
R</span>.</p>
<h2 data-number="1.2" id="optimization-problem"><span
class="header-section-number">1.2</span> optimization problem</h2>
<p>A problem of finding a minimum/maximum of a objective function.</p>
<h3 data-number="1.2.1"
id="decision-problem---optimization-problem"><span
class="header-section-number">1.2.1</span> decision problem &lt;-&gt;
optimization problem</h3>
<p><span class="math inline">G</span> - graph,</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>optimization problem</th>
<th>decision problem</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\chi(G) =\ ?</span></td>
<td>does exist a proper vertex coloring of <span
class="math inline">G</span> with <span class="math inline">k</span>
colors?</td>
</tr>
</tbody>
</table>
<h2 data-number="1.3" id="encoding-1"><span
class="header-section-number">1.3</span> encoding</h2>
<ul>
<li><span class="math inline">\Pi</span> - a decision problem</li>
<li><span class="math inline">|\cdot|: D_\Pi \to N</span> instance size
function, should be independent of reasonable encodings</li>
</ul>
<p>For <span class="math inline">I \in D_\Pi</span> <span
class="math inline">|I| =</span> size of <span
class="math inline">I</span>.</p>
<p>For every reasonable encoding <span class="math inline">e</span>
there exist polynomials <span class="math inline">p, p&#39;</span> such
that <span class="math inline">|I| \le p(|e(I)|)</span> and <span
class="math inline">|e(I)| \le p&#39;(|I|)</span> for every <span
class="math inline">I \in D_\Pi</span>.</p>
<p>Example of standard encoding scheme:</p>
<p><span class="math inline">\Sigma = \{0, 1, -, [, ], (, ),
,\}</span></p>
<p>We recursively define structured strings</p>
<ol type="1">
<li><span class="math inline">k\in \mathbb Z</span> is represented as a
binary string (preceded with <span class="math inline">-</span> if <span
class="math inline">k &lt; 0</span>)</li>
<li>if <span class="math inline">x</span> is a structured string then
<span class="math inline">[x]</span> is a structured string that can be
used as a name of some object</li>
<li>if <span class="math inline">x_1, \cdots, x_n</span> are structured
string representing objects <span class="math inline">X_1, \cdots,
X_n</span> then <span class="math inline">(x_1, \cdots, x_n)</span> is a
structured string</li>
</ol>
<h2 data-number="1.4" id="complexity"><span
class="header-section-number">1.4</span> complexity</h2>
<p><span class="math inline">A</span> - algorithm, <span
class="math inline">I \in D_\Pi</span>, <span class="math inline">|I|
=</span> input size = the number of cells of <span
class="math inline">A</span> used to input <span
class="math inline">I</span> (<span
class="math inline">|e(I)|</span>)</p>
<p>The time complexity of <span class="math inline">A</span> is a
function <span class="math inline">T_A: N \to N</span></p>
<p><span class="math display">
T_A(n) = \max_{I \in D_\Pi, |I| = n}\{\text{the number of steps
performed by A during the computation on input I}\}
</span></p>
<h3 data-number="1.4.1" id="non-deterministic-algorithm"><span
class="header-section-number">1.4.1</span> non-deterministic
algorithm</h3>
<p>NTM with stop property. The tree of computation is finite. Halts for
every sequence of choices.</p>
<p>Let <span class="math inline">A</span> be a non-deterministic
algorithm for solving <span class="math inline">\Pi</span>.</p>
<p>The time complexity of <span class="math inline">A</span> is a
function <span class="math inline">T_A: N \to N</span></p>
<p><span class="math display">
T_A(n) = \max_{I \in D_\Pi, |I| = n}\{\sup(\text{number of moves in
every path from root to a leaf in the computation tree of A on input
I})\}
</span></p>
<h3 data-number="1.4.2" id="asymptotic-notation"><span
class="header-section-number">1.4.2</span> asymptotic notation</h3>
<h4 data-number="1.4.2.1" id="big-o"><span
class="header-section-number">1.4.2.1</span> big O</h4>
<p><span class="math inline">f, g: N \to \mathbb R</span> (increasing
functions)</p>
<p><span class="math inline">f(n) = O(g(n))</span> if <span
class="math inline">\exists_{C &gt; 0} \exists_{n_0 \in N} \forall_{n
\ge n_0} f(n) \le C \cdot g(n)</span></p>
<p><span class="math inline">A</span> is called a polynomial time
algorithm if there exists a polynomial <span
class="math inline">p</span> such that <span class="math inline">T_A(n)
= O(p(n))</span>. Otherwise <span class="math inline">A</span> is called
an exponential time algorithm.</p>
<h2 data-number="1.5" id="polynomial-time-transformation"><span
class="header-section-number">1.5</span> polynomial time
transformation</h2>
<h3 data-number="1.5.1" id="of-languages"><span
class="header-section-number">1.5.1</span> of languages</h3>
<p><span class="math inline">L_1 \subseteq \Sigma_1^*</span>, <span
class="math inline">L_2 \subseteq \Sigma_2^*</span> - languages</p>
<p>A polynomial time transformation from <span
class="math inline">L_1</span> to <span class="math inline">L_2</span>
is a function <span class="math inline">f: \Sigma_1^* \to
\Sigma_2^*</span> such that</p>
<ol type="1">
<li>there exists a deterministic polynomial time algorithm computing
<span class="math inline">f</span></li>
<li><span class="math inline">\forall_{x \in \Sigma_1^*} x\in L_1 \iff
f(x) \in L_2</span></li>
</ol>
<p>denoted by <span class="math inline">L_1 \alpha L_2</span></p>
<h3 data-number="1.5.2" id="of-decision-problems"><span
class="header-section-number">1.5.2</span> of decision problems</h3>
<p><span class="math inline">\Pi_1, \Pi_2</span> - decision problems</p>
<p>A polynomial time transformation from <span
class="math inline">\Pi_1</span> to <span
class="math inline">\Pi_2</span> is a function <span
class="math inline">f: D_{\Pi_1} \to D_{\Pi_2}</span> such that</p>
<ol type="1">
<li>there exists a deterministic polynomial time algorithm computing
<span class="math inline">f</span></li>
<li><span class="math inline">\forall_{I \in D_{\Pi_1}} I \in Y_{\Pi_1}
\iff f(I) \in Y_{\Pi_2}</span></li>
</ol>
<p>denoted by <span class="math inline">\Pi_1 \alpha \Pi_2</span></p>
<p>This relation is reflexive and transitive.</p>
<h2 data-number="1.6" id="polynomial-equivalence"><span
class="header-section-number">1.6</span> polynomial equivalence</h2>
<ul>
<li><span class="math inline">L_1, L_2</span> are polynomial equivalent
if <span class="math inline">L_1 \alpha L_2</span> and <span
class="math inline">L_2 \alpha L_1</span></li>
<li><span class="math inline">\Pi_1, \Pi_2</span> are polynomial
equivalent if <span class="math inline">\Pi_1 \alpha \Pi_2</span> and
<span class="math inline">\Pi_2 \alpha \Pi_1</span></li>
</ul>
<h2 data-number="1.7" id="classes"><span
class="header-section-number">1.7</span> classes</h2>
<ul>
<li><span class="math inline">P</span> - the class of problems that can
be solved by a deterministic polynomial time algorithms</li>
<li><span class="math inline">NP</span> - the class of problems that can
be solved by a non-deterministic polynomial time algorithm</li>
<li><span class="math inline">coNP = \{\bar\Pi: \Pi \in NP\}</span></li>
<li><span class="math inline">NPC = \{\Pi \in NP : \forall_{\Pi&#39; \in
NP} \Pi&#39; \alpha \Pi\}</span> (NP-complete)</li>
</ul>
<hr />
<ul>
<li>polynomial time - fast</li>
<li>exponential time - slow</li>
<li>problems from P - easy</li>
<li>problems not from P - hard</li>
<li>problems from NP - solve by non-deterministic algorithm in
polynomial time <span class="math inline">\lor</span> check the solution
by deterministic algorithm in polynomial time</li>
</ul>
<p>Theorem: <span class="math inline">L \in NP \iff</span> there exists
a language <span class="math inline">L_{\text{check}} \in P</span> and a
polynomial <span class="math inline">p</span> such that <span
class="math inline">L = \{x : \exists_{y} (x, y) \in L_{\text{check}}
\land |y| \le p(|x|)\}</span>. <span class="math inline">y</span> is
called a certificate for <span class="math inline">x</span>.</p>
<p>Proof:</p>
<p><span class="math inline">\impliedby</span></p>
<p>Let <span class="math inline">M</span> be a deterministic algorithm
such that <span class="math inline">L(M) = L_{\text{check}}</span>. We
construct a non-deterministic algorithm <span
class="math inline">M&#39;</span> such that <span
class="math inline">L(M&#39;) = L</span>. First <span
class="math inline">M&#39;</span> guesses <span
class="math inline">y</span> (the number of candidates is bounded
because <span class="math inline">|y| \le p(|x|)</span>). Then <span
class="math inline">M&#39;</span> runs <span
class="math inline">M</span> on <span class="math inline">(x, y)</span>
and checks the answer.</p>
<p><span class="math inline">\implies</span></p>
<p>Let <span class="math inline">M</span> be a nondeterministic
algorithm such that <span class="math inline">L(M) = L</span>.
Computation of <span class="math inline">M</span> on input string <span
class="math inline">x</span>. Any path from the root in the tree of
computation of <span class="math inline">M</span> on input <span
class="math inline">x</span> has length <span class="math inline">\le
p(|x|)</span> for some polynomial <span class="math inline">p</span>. We
define <span class="math inline">L_{\text{check}}</span>. <span
class="math inline">(x, y) \in L_{\text{check}} \iff y</span> is a code
of computation path of <span class="math inline">M</span> on input <span
class="math inline">x</span> which ends in accepting state. Now we show
that <span class="math inline">L_{\text{check}} \in P</span>. We
construct a deterministic algorithm <span
class="math inline">M&#39;</span> such that <span
class="math inline">L(M&#39;) = L_{\text{check}}</span>. <span
class="math inline">M&#39;</span> check if <span
class="math inline">y</span> is a correct code of computation path of
<span class="math inline">M</span> on input <span
class="math inline">x</span> and checks if it ends in accepting
state.</p>
<h2 data-number="1.8" id="npc"><span
class="header-section-number">1.8</span> NPC</h2>
<p>If <span class="math inline">\Pi_1, \Pi_2 \in NP</span>, <span
class="math inline">\Pi_1 \in NPC</span> and <span
class="math inline">\Pi_1 \alpha \Pi_2</span> then <span
class="math inline">\Pi_2 \in NPC</span>.</p>
<p>If <span class="math inline">\Pi \in NP</span> then <span
class="math inline">\Pi</span> can be solved on DTM in exponential time.
Question: if <span class="math inline">\Pi \in NP</span> then can <span
class="math inline">\Pi</span> be solved on DTM in polynomial time?</p>
<h3 data-number="1.8.1" id="textsat-problem-satisfiability"><span
class="header-section-number">1.8.1</span> <span
class="math inline">\text{SAT}</span> problem (satisfiability)</h3>
<p>Logic formula in CNF = a conjunction of clauses, each clause is a
disjunction of literals, a literal is a variable or negated
variable.</p>
<p>Example: <span class="math inline">F = (x_1 \lor \neg x_2 \lor x_3)
\land (\neg x_1 \lor x_2) \land (\neg x_2 \lor x_3 \lor \neg
x_4)</span></p>
<p><span class="math inline">X = \{x_1, \cdots, x_n\}</span> a set of
variables, <span class="math inline">F</span> - a formula in CNF with
variables from <span class="math inline">X</span>. An assignment is
<span class="math inline">v: X \to \{0, 1\}</span>. There are <span
class="math inline">2^n</span> assignments.</p>
<p>Question: does there exist an assignment <span
class="math inline">v</span> that satisfies <span
class="math inline">F</span>? Such assignment is called a satisfying
assignment. <span class="math inline">v</span> satisfies <span
class="math inline">F</span> <span class="math inline">\iff</span> <span
class="math inline">v</span> satisfies every clause of <span
class="math inline">F</span>.</p>
<h4 data-number="1.8.1.1" id="cook-theorem"><span
class="header-section-number">1.8.1.1</span> Cook theorem</h4>
<p><span class="math inline">\text{SAT} \in NPC</span>.</p>
<h5 data-number="1.8.1.1.1" id="proof"><span
class="header-section-number">1.8.1.1.1</span> proof</h5>
<ol type="1">
<li><span class="math inline">\text{SAT} \in NP</span></li>
</ol>
<p>We construct a NTM with stop property <span
class="math inline">M</span> for solving <span
class="math inline">\text{SAT}</span>. First <span
class="math inline">M</span> guesses an assignment (<span
class="math inline">O(n)</span>) and then checks if this assignment
satisfies every clause (polynomial time).</p>
<ol start="2" type="1">
<li>Let <span class="math inline">L \in NP</span>. We will show <span
class="math inline">L \alpha \text{SAT}</span></li>
</ol>
<p>Let <span class="math inline">M</span> be a NTM with stop property
such that <span class="math inline">L(M) = L</span>. Let <span
class="math inline">w</span> be an input string. We will construct <span
class="math inline">f(w)</span> - an instance of <span
class="math inline">\text{SAT}</span> such that <span
class="math inline">w \in L \implies f(w)</span> is satisfiable. We
assume <span class="math inline">M</span> has one tape. Let <span
class="math inline">p(n)</span> be a polynomial such that <span
class="math inline">T_M(n) \le p(n)</span>. We can assume that <span
class="math inline">p(n) \ge n</span>. <span class="math inline">M = (Q,
\Sigma, \Gamma, \delta, B, q_1, \{q_s\}, \{q_{s-q}\})</span> with <span
class="math inline">Q = \{q_1, \cdots, q_s\}</span>, <span
class="math inline">\Gamma = \{X_1, \cdots, X_m\}</span>, <span
class="math inline">B = X_m</span>, <span class="math inline">s,
m</span> - const. Let <span class="math inline">|w| = n</span>. We
assume that if <span class="math inline">M</span> finishes the
computation before <span class="math inline">p(n)</span> steps then it
stays in the accepting state or the rejecting state and halts in moment
<span class="math inline">p(n)</span>, so the computation of <span
class="math inline">M</span> always takes <span
class="math inline">p(n)</span> steps. Variables:</p>
<ul>
<li><span class="math inline">C(i, j, t)</span>: <span
class="math inline">C(i, j, t) = 1 \iff</span> on the tape of <span
class="math inline">M</span> there is symbol <span
class="math inline">X_j</span> in the <span
class="math inline">i</span>-th cell in moment <span
class="math inline">t</span>. <span class="math inline">1 \le i \le
p(n)</span>, <span class="math inline">1 \le j \le m</span>, <span
class="math inline">0 \le t \le p(n)</span>. Otherwise the value is
0.</li>
<li><span class="math inline">S(k, t)</span>: <span
class="math inline">S(k, t) = 1 \iff</span> <span
class="math inline">M</span> is in state <span
class="math inline">q_k</span> in moment <span
class="math inline">t</span>. <span class="math inline">1 \le k \le
s</span>, <span class="math inline">0 \le t \le p(n)</span>. Otherwise
the value is 0.</li>
<li><span class="math inline">H(i, t)</span>: <span
class="math inline">H(i, t) = 1 \iff</span> the head of <span
class="math inline">M</span> observes <span
class="math inline">i</span>-th cell in moment <span
class="math inline">t</span>. <span class="math inline">1 \le i \le
p(n)</span>, <span class="math inline">0 \le t \le p(n)</span>.</li>
</ul>
<p>There are <span class="math inline">p(n) \cdot m \cdot (p(n) + 1) + s
\cdot (p(n) + 1) + p(n) \cdot (p(n) + 1) = \Theta(p^2(n))</span>
variables. By <span class="math inline">|F|</span> we denote the length
of the formula = the number of literals in <span
class="math inline">F</span>. Let <span class="math inline">U(x_1,
\cdots, x_r) = (x_1 \lor x_2 \lor \cdots \lor x_r) \land (\neg x_1 \lor
\neg x_2) \land (\neg x_1 \lor \neg x_3) \land \cdots \land (\neg
x_{r-1} \lor \neg x_r)</span>. So <span class="math inline">U(x_1,
\cdots, x_r) = 1 \iff</span> for exactly one <span class="math inline">i
\in \{1, \cdots, r\}</span>, <span class="math inline">x_i = 1</span>.
<span class="math inline">|U| = O(r^2)</span>. There will be 7 types of
clauses in <span class="math inline">f(w)</span> describing
conditions.</p>
<ol type="1">
<li>in every moment <span class="math inline">t</span> the head observes
exactly one cell. <span class="math inline">F_1 = \bigwedge_{0 \le t \le
p(n)} A_t</span> where <span class="math inline">A_t = U(H(1, t),
\cdots, H(p(n), t))</span>. <span class="math inline">|A_t| =
O(p^2(n))</span>, <span class="math inline">|F_1| = p(n+1) \cdot
O(p^2(n)) = O(p^3(n))</span>.</li>
<li>in every moment <span class="math inline">t</span> there is exactly
one symbol in every cell. <span class="math inline">F_2 = \bigwedge_{0
\le t \le p(n), 1 \le i \le p(n)} B_{i, t}</span> where <span
class="math inline">B_{i, t} = U(C(i, 1, t), \cdots, C(i, m, t))</span>.
<span class="math inline">|B_{i,t}| = O(m^2) =</span> const, <span
class="math inline">|F_2| = (p(n) + 1)p(n) \cdot O(1) =
O(p^2(n))</span></li>
<li>in every moment <span class="math inline">t</span> <span
class="math inline">M</span> is in exactly one state. <span
class="math inline">F_3 = \bigwedge_{0 \le t \le p(n)}U(S(1, t), \cdots,
S(s, t))</span>. <span class="math inline">|F_3| = (p(n) + 1) \cdot
O(s^2) = O(p(n))</span></li>
<li>in every moment <span class="math inline">t</span> a symbol changes
in at most one cell. <span class="math inline">F_4 = \bigwedge_{0 \le t
\le p(n), 1 \le i \le p(n), 1 \le j \le m} D_{i, j, t}</span>. We want
<span class="math inline">D_{i, j, t} \iff ((C(i, j,t) \implies C(i, j,
t+1)) \lor H(i, t))</span>. <span class="math inline">|F_4| =
O(p^2(n))</span></li>
<li>in every moment <span class="math inline">t</span> the computation
of <span class="math inline">M</span> is described by <span
class="math inline">\delta</span>. <span class="math inline">F_5 =
\bigwedge_{0 \le t \le p(n), 1 \le i \le p(n), 1 \le j \le m, 1 \le k
\le s} E_{i, j, k, t}</span>. Let <span class="math inline">\delta(q_k,
X_j) = \{(q_{k_1}, X_{j_1}, K_{i_1}), \cdots, (q_{k_{x(k, j)}},
X_{j_{x(k, j)}}, K_{i_{x(k, j)}})\}</span>. We want <span
class="math inline">E_{i,j,k,t} = ((C(i, j, t) \land H(i, t) \land S(k,
t)) \implies \bigvee_{1 \le l \le x(k, j)}(C(i, j_l, t+1) \land H(i_l,
t+1) \land S(k_l, t+1)))</span>. <span class="math inline">|E_{i,j,k,t}|
= O(3^{2sm} \cdot 2sm + 3) =</span> const. <span
class="math inline">|F_5| = (p(n) + 1) \cdot p(n) \cdot m \cdot s \cdot
O(1) = O(p^2(n))</span>.</li>
<li>in <span class="math inline">t=0</span> <span
class="math inline">M</span> is in initial state. <span
class="math inline">F_6 = S(1, 0) \land H(1, 0) \land \bigwedge_{1 \le i
\le n} C(i, j_i, 0) \land \bigwedge_{n &lt; i \le p(n)}C(i, m, 0)</span>
where <span class="math inline">w = X_{j_1}X_{j_2}\cdots X_{j_n}</span>.
<span class="math inline">|F_6| = O(p(n))</span>.</li>
<li>in moment <span class="math inline">p(n)</span> <span
class="math inline">M</span> is in accepting state or rejecting state
<span class="math inline">F_7 = S(s, p(n))</span>. <span
class="math inline">|F_7| = O(1)</span>.</li>
</ol>
<p>So <span class="math inline">f(w) = F_1 \land F_2 \land F_3 \land F_4
\land F_5 \land F_6 \land F_7</span>. The number of literals in <span
class="math inline">f(w)</span> is <span
class="math inline">O(p^3(n))</span>. There are <span
class="math inline">\Theta(p^2(n))</span> variables <span
class="math inline">\implies</span> the length of variable is <span
class="math inline">O(\beta\log n)</span> where <span
class="math inline">\beta</span> depends on <span
class="math inline">p</span>. The length of <span
class="math inline">|f(w)| = O(p^3(n) \beta \log n) = O(p^4(n))</span>.
<span class="math inline">f(w) = 1 \iff</span> <span
class="math inline">M</span> halts in accepting state <span
class="math inline">\iff w \in L(M) = L</span>. <span
class="math inline">f(w)</span> can be constructed in polynomial time.
<span class="math inline">\square</span></p>
<h3 data-number="1.8.2" id="list-of-npc-problems"><span
class="header-section-number">1.8.2</span> list of NPC problems</h3>
<ol type="1">
<li><span class="math inline">\text{SAT}</span></li>
<li><span class="math inline">3\text{SAT}</span> (<span
class="math inline">\text{SAT}</span> where each clause has exactly 3
literals)</li>
<li>Vertex Cover (VC), Clique, Independent Set (IS)</li>
<li>Hamiltonian Cycle (HC)</li>
<li>Partition</li>
<li>Traveling Salesman Problem (TSP)</li>
<li>Dominating Set (DS)</li>
</ol>
<h4 data-number="1.8.2.1" id="ds"><span
class="header-section-number">1.8.2.1</span> DS</h4>
<p>A dominating set in a graph <span class="math inline">G</span> is a
set <span class="math inline">W \subseteq V</span> such that <span
class="math inline">\forall_{v \in V \setminus W}</span> <span
class="math inline">v</span> has at least one neighbor in <span
class="math inline">W</span>.</p>
<p>Instance: <span class="math inline">G=(V, E), k \in N</span></p>
<p>Question: Does there exist a dominating set <span
class="math inline">W</span> in <span class="math inline">G</span> such
that <span class="math inline">|W| \le k</span>?</p>
<h4 data-number="1.8.2.2" id="tsp"><span
class="header-section-number">1.8.2.2</span> TSP</h4>
<p><span class="math inline">K_n</span> - complete graph, <span
class="math inline">w: E(K_n) \to N</span> - a weight function, <span
class="math inline">b \in N</span></p>
<p>Instance: <span class="math inline">K_n, w, b</span></p>
<p>Question: Does there exist a Hamiltonian cycle <span
class="math inline">v_1v_2\cdots v_nv_1</span> in <span
class="math inline">K_n</span> such that <span
class="math inline">\sum_{i=1}^{n-1}w(v_iv_{i+1}) + w(v_nv_1) \le
b</span>.</p>
<h4 data-number="1.8.2.3" id="partition"><span
class="header-section-number">1.8.2.3</span> Partition</h4>
<p><span class="math inline">X = \{x_1, \cdots, x_n\}</span> <span
class="math inline">f: X \to N</span> - a weight function.</p>
<p>Instance: <span class="math inline">X, f</span></p>
<p>Question: Does there exist a set <span class="math inline">X&#39;
\subseteq X</span> such that <span class="math inline">\sum_{x_i \in
X&#39;}f(x_i) = \sum_{x_i \in X \setminus X&#39;}f(x_i)</span></p>
<h4 data-number="1.8.2.4" id="vc-clique-is"><span
class="header-section-number">1.8.2.4</span> VC, Clique, IS</h4>
<ol type="1">
<li><strong>VC</strong>: Instance: <span class="math inline">G = (V, E),
k \in N</span>. Question: Does there exist a vertex cover <span
class="math inline">W</span> of <span class="math inline">G</span> such
that <span class="math inline">|W| \le k</span>?</li>
<li><strong>Clique</strong>: Instance: <span class="math inline">G = (V,
E), l \in N</span>. Question: Does there exist a clique <span
class="math inline">W</span> in <span class="math inline">G</span> such
that <span class="math inline">|W| \ge l</span>?</li>
<li><strong>IS</strong>: Instance: <span class="math inline">G = (V, E),
j \in N</span>. Question: Does there exist an independent set <span
class="math inline">W</span> in <span class="math inline">G</span> such
that <span class="math inline">|W| \ge j</span>?</li>
</ol>
<p>For <span class="math inline">W \subseteq V</span> the following
conditions are equivalent:</p>
<ul>
<li><span class="math inline">W</span> is a vertex cover of <span
class="math inline">G</span></li>
<li><span class="math inline">V \setminus W</span> is an independent set
in <span class="math inline">G</span></li>
<li><span class="math inline">V \setminus W</span> is a clique in <span
class="math inline">\bar G = (V, \binom{V}{2} \setminus E)</span></li>
</ul>
<p>So these 3 problems can be seen as different versions of the same
problem. Any of these problems can be easily transformed to either of
the others. For instance, to transform VC to Clique: let <span
class="math inline">(G = (V, E), k)</span> be an instance of VC. The
corresponding instance of Clique is <span class="math inline">(\bar G,
|V| - k)</span> which can be obtained with a transformation in
polynomial time. Thus if one of the problems is NPC, then other are
too.</p>
<h4 data-number="1.8.2.5" id="vc-is-npc"><span
class="header-section-number">1.8.2.5</span> VC is NPC</h4>
<ol type="1">
<li>VC <span class="math inline">\in\text{NP}</span></li>
</ol>
<p>A nondeterministic algorithm guesses a subset of vertices and checks
in polynomial time whether this subset is a VC and has correct
cardinality.</p>
<ol start="2" type="1">
<li><span class="math inline">\text{3SAT} \alpha \text{VC}</span></li>
</ol>
<p>Let <span class="math inline">X = \{x_1, \cdots, x_n\}</span> and let
<span class="math inline">F = c_1 \land \cdots \land c_m</span> be a
<span class="math inline">\text{3SAT}</span> instance. We will construct
a graph <span class="math inline">G = (V, E)</span> and a natural number
<span class="math inline">k \le |V|</span> such that <span
class="math inline">G</span> has a vertex cover of cardinality at most
<span class="math inline">k \iff F</span> is satisfiable.</p>
<p>Components: truth-setting components + satisfaction testing
components + communication edges.</p>
<p>For every variable <span class="math inline">x_i</span> there is a
truth-setting component <span class="math inline">T_i = (V_i,
E_i)</span> where <span class="math inline">V_i = \{x_i, \neg
x_i\}</span> and <span class="math inline">E_i = \{\{x_i, \neg
x_i\}\}</span>, so it is a <span class="math inline">K_2</span>. Note
that any vertex cover will have to contain at least one of the two
vertices of <span class="math inline">E_i</span> in order to cover this
edge.</p>
<p>For every clause <span class="math inline">c_j</span> in <span
class="math inline">F</span> there is a satisfaction testing component
<span class="math inline">S_j = (V_j&#39;, E_j&#39;)</span> where <span
class="math inline">V_j&#39; = \{a_1(j), a_2(j), a_3(j)\}</span> and
<span class="math inline">E_j&#39; = \{\{a_1(j), a_2(j)\},\{a_1(j),
a_3(j)\},\{a_2(j), a_3(j)\}\}</span> so it is a <span
class="math inline">K_3</span>. Note that any vertex cover will have to
contain at least two vertices from <span
class="math inline">V_j&#39;</span> to cover the edges of <span
class="math inline">E_j&#39;</span>.</p>
<p>For <span class="math inline">c_j</span> in <span
class="math inline">F</span> let the three literals in <span
class="math inline">c_j</span> be denoted by <span
class="math inline">y_j, z_j, w_j</span>. So <span
class="math inline">c_j = (y_j \lor z_j \lor w_j)</span>. The
communication edges for <span class="math inline">S_j</span> are <span
class="math inline">E_j&#39;&#39; = \{\{a_1(j), y_j\}, \{a_2(j), z_j\},
\{a_3(j), w_j\}\}</span>. Out instance of VC is <span
class="math inline">G = (V, E)</span> where <span class="math inline">V
= \bigcup_{i=1}^nV_i \cup \bigcup_{j=1}^m V_j&#39;</span> and <span
class="math inline">E = \bigcup_{i=1}^n E_i \cup \bigcup_{j=1}^m
E_j&#39; \cup \bigcup_{j=1}^m E_j&#39;&#39;</span> and <span
class="math inline">k = n + 2m</span>.</p>
<p>One can see that <span class="math inline">(G, k)</span> can be
constructed in polynomial time.</p>
<p><span class="math inline">F</span> is satisfiable <span
class="math inline">\iff</span> <span class="math inline">G</span> has a
vertex cover of cardinality <span class="math inline">\le k</span>.</p>
<p><span class="math inline">\impliedby</span> Suppose that <span
class="math inline">W \subseteq V</span> is a vertex cover of <span
class="math inline">G</span> and <span class="math inline">|W| \le
k</span>. By our previous remarks <span class="math inline">W</span> has
to contain at least one vertex from every <span
class="math inline">T_i</span> and at least two vertices from every
<span class="math inline">S_j</span>. Since it gives a total of at least
<span class="math inline">n + 2m = k</span> vertices, <span
class="math inline">|W| = k</span> and <span
class="math inline">W</span> must contain exactly one vertex from every
<span class="math inline">T_i</span> and exactly two vertices from every
<span class="math inline">S_j</span>. We use the vertices of <span
class="math inline">W</span> contained in <span
class="math inline">T_i</span>s to define an assignment <span
class="math inline">V: X \to \{0, 1\}</span>. We set <span
class="math inline">v(x_i) = 1</span> if <span class="math inline">x_i
\in W</span> and <span class="math inline">v(x_i) = 0</span> otherwise.
We will show that <span class="math inline">v</span> satisfies every
clause <span class="math inline">c_j</span> in <span
class="math inline">F</span>. Consider three communication edges in
<span class="math inline">E&#39;&#39;_j</span>. Only two of these edges
can be covered by vertices from <span class="math inline">V_j&#39; \cap
W</span>, so one of them must be covered by a vertex from <span
class="math inline">V_i \cap W</span> for some <span
class="math inline">i</span>. But that implies that the corresponding
literal (<span class="math inline">x_i</span> or <span
class="math inline">\neg x_i</span>) is true under assignment <span
class="math inline">v</span>, so <span class="math inline">c_j</span> is
satisfied by <span class="math inline">v</span>. Because it holds for
every clause <span class="math inline">c_j</span> in <span
class="math inline">F</span>, <span class="math inline">v</span> is a
satisfying assignment for <span class="math inline">F</span>.</p>
<p><span class="math inline">\implies</span> Suppose that <span
class="math inline">v: X \to \{0, 1\}</span> is a satisfying assignment
for <span class="math inline">F</span>. THe corresponding vertex cover
<span class="math inline">W</span> will contain one vertex from every
<span class="math inline">T_i</span> and two vertices from every <span
class="math inline">S_j</span> (<span class="math inline">n + 2m = k \le
k</span> vertices). The vertex from <span class="math inline">T_i</span>
in <span class="math inline">W</span> is <span
class="math inline">x_i</span> if <span class="math inline">v(x_i) =
1</span> and <span class="math inline">\neg x_i</span> otherwise. This
ensures that at least one of the three edges in every <span
class="math inline">E&#39;&#39;_j</span> is covered, because <span
class="math inline">v</span> satisfies every clause <span
class="math inline">c_j</span>. Therefore we need to include in <span
class="math inline">W</span> the ends in <span
class="math inline">V&#39;_j</span> of the other two edges from <span
class="math inline">E_j&#39;&#39;</span> (which may or may not be also
covered by vertices from <span class="math inline">T_i</span>s. <span
class="math inline">\square</span></p>
<h4 data-number="1.8.2.6" id="hc-is-npc"><span
class="header-section-number">1.8.2.6</span> HC is NPC</h4>
<ol type="1">
<li>HC <span class="math inline">\in \text{NP}</span></li>
</ol>
<p>A non-deterministic algorithm guesses a permutation of the vertices
and checks in polynomial time whether it is a hamiltonian cycle.</p>
<ol start="2" type="1">
<li>VC <span class="math inline">\alpha</span> HC</li>
</ol>
<p>Let <span class="math inline">G = (V, E)</span> and <span
class="math inline">k \in N</span> be an instance of VC. we will
construct a graph <span class="math inline">G&#39;=(V&#39;,
E&#39;)</span> such that <span class="math inline">G</span> contains a
vertex cover of cardinality <span class="math inline">\le k</span> <span
class="math inline">\iff</span> <span class="math inline">G&#39;</span>
has a hamiltonian cycle.</p>
<p>Components: selector vertices + cover testing components +
communication edges</p>
<p><span class="math inline">G&#39;</span> will contain <span
class="math inline">k</span> selector vertices <span
class="math inline">S = \{a_1, \cdots, a_k\}</span>.</p>
<p>For every edge <span class="math inline">e = \{u, v\} \in E</span>
there is a cover testing component <span class="math inline">C_e =
(V_e&#39;, E_e&#39;)</span> where <span class="math inline">V_e&#39; =
\{(u, e, i), (v, e, i) : 1 \le i \le 6\}</span> and <span
class="math inline">E&#39;_e = \{\{(u, e, i), (u, e, i+1)\}, \{(v, e,
i), (v, e, i+1)\}: 1 \le i \le 5\} \cup \{\{(u, e, 3), (v, e, 1)\},
\{(v, e, 3), (u, e, 1)\}, \{(u, e, 6), (v, e, 4)\}, \{(v, e, 6), (u, e,
4)\}\}</span>.</p>
<p>In the completed construction only vertices of this component that
will be incident with communication edges are <span
class="math inline">(u, e, 1), (u, e, 6), (v, e, 1), (v, e, 6)</span>.
Any Hamiltonian cycle in <span class="math inline">G&#39;</span> will
have to traverse this cover testing component in exactly one of three
configuration. For every vertex <span class="math inline">v \in V</span>
let the edges incident with <span class="math inline">v</span> be
ordered (arbitrarily) as <span class="math inline">e_{v(1)}, e_{v(2)},
\cdots, e_{v(d(v))}</span> where <span class="math inline">d(v) =</span>
degree of <span class="math inline">v</span>. All the cover testing
components corresponding to these edges are joined with the following
communication edges <span class="math inline">E_v&#39; = \{\{(v,
e_{v(i)}, 6), (v, e_{v(i+1)}, 1)\}: 1 \le i &lt; d(v)\}</span>. The
final communication edges join the ends of these paths to every one of
the selector vertices. These are the following edges <span
class="math inline">E&#39;&#39; = \{\{a_i, (v, e_{v(1)}, 1)\}, \{a_i,
(v, e_{d(v)}, 6)\}: 1 \le i \le k, v \in V\}</span>. Our instance of HC
is <span class="math inline">G&#39;=(V&#39;, E&#39;)</span> where <span
class="math inline">V&#39; = S \cup \bigcup_{e \in E} V_e&#39;</span>
and <span class="math inline">E&#39; = \bigcup_{e \in E} E_e&#39; \cup
\bigcup_{v \in V} E_v&#39; \cup E&#39;&#39;</span>. One can see that we
can construct <span class="math inline">G&#39;</span> from <span
class="math inline">G</span> and <span class="math inline">k</span> in
polynomial time.</p>
<p><span class="math inline">G</span> has a vertex cover of cardinality
<span class="math inline">\le k</span> <span
class="math inline">\iff</span> <span class="math inline">G&#39;</span>
has a Hamiltonian cycle.</p>
<p><span class="math inline">\impliedby</span> Suppose <span
class="math inline">v_1, v_2, \cdots, v_n, v_1</span> where <span
class="math inline">n = |V&#39;|</span> is a Hamiltonian cycle in <span
class="math inline">G&#39;</span>. Consider any minimal subpath of the
cycle that begins and ends in a vertex from <span
class="math inline">S</span>. Because of the previously described
restrictions on the way in which the Hamiltonian cycle can pass through
a cover testing component, this fragment of our cycle must pass through
a set of cover testing components corresponding to exactly these edges
from <span class="math inline">E</span> which are incident with some one
particular vertex <span class="math inline">v \in V</span>. Each of the
cover testing components is traversed in one of the three ways and no
vertex from any other cover testing component is visited. Thus the <span
class="math inline">k</span> selector vertices divide our Hamiltonian
cycle into <span class="math inline">k</span> paths, each path
corresponding to a different vertex <span class="math inline">v \in
V</span>. Since the Hamiltonian cycle must visit all vertices from all
cover testing components and since vertices from the cover testing
component corresponding to and edge <span class="math inline">e \in
E</span> can be traversed only by a path corresponding to one of the
ends of <span class="math inline">e</span>, every edge <span
class="math inline">e \in E</span> must have at least one end among
those selected vertices from <span class="math inline">V</span>.
Therefore this set of <span class="math inline">k</span> vertices forms
a vertex cover of <span class="math inline">G</span>.</p>
<p><span class="math inline">\implies</span> Suppose <span
class="math inline">W \subseteq V</span> is a vertex cover of <span
class="math inline">G</span> and <span class="math inline">|W| \le
k</span>. We can assume that <span class="math inline">|W| = k</span>
(otherwise we can just add some vertices to <span
class="math inline">W</span>). We choose the edges of a Hamiltonian
cycle in <span class="math inline">G&#39;</span>. From the cover testing
components corresponding to the edge <span class="math inline">\{u, v\}
\in E</span> we choose the edges specified by <span
class="math inline">(a), (b)</span>, or <span
class="math inline">(c)</span> depending on whether <span
class="math inline">\{u, v\} \cap W</span> equals <span
class="math inline">\{u\}</span>, <span class="math inline">\{u,
v\}</span>, or <span class="math inline">\{v\}</span> respectively, one
of those must occur because <span class="math inline">W</span> is a
vertex cover of <span class="math inline">G</span>. Next we choose the
edges in <span class="math inline">E_{v_i}&#39;</span> for <span
class="math inline">1 \le i \le k</span>. Finally we choose the edges
<span class="math inline">\{\{a_i, (v_i, e_{v_i(1)}, 1)\}: 1 \le i \le
k\}</span>, <span class="math inline">\{\{a_{i+1}, (v_i,
e_{v_i(d(v_i))}, 6)\}: 1 \le i &lt; k\}</span>, and <span
class="math inline">\{a_1, (v_k, e_{v_k(d(v_k))}, 6)\}</span>. The
subgraph of <span class="math inline">G&#39;</span> induced by these
edges is a hamiltonian cycle.</p>
<h4 data-number="1.8.2.7" id="tsp-is-npc"><span
class="header-section-number">1.8.2.7</span> TSP is NPC</h4>
<ol type="1">
<li>TSP <span class="math inline">\in NP</span></li>
</ol>
<p>A non-deterministic algorithm guesses a permutation of vertices and
checks in polynomial time if the sum of weights of the corresponding
Hamiltonian cycle is <span class="math inline">\le b</span>.</p>
<ol start="2" type="1">
<li>restriction: if <span class="math inline">w(e) \in \{1, n+1\}</span>
for every <span class="math inline">e \in E</span> and <span
class="math inline">b = n</span> then we obtain HC problem</li>
</ol>
<h4 data-number="1.8.2.8" id="ds-is-npc"><span
class="header-section-number">1.8.2.8</span> DS is NPC</h4>
<ol type="1">
<li>DS <span class="math inline">\in NP</span></li>
</ol>
<p>A non-deterministic algorithm guesses a subset of vertices and checks
in polynomial time whether this subset is a dominating set and has
cardinality <span class="math inline">\le k</span>.</p>
<ol start="2" type="1">
<li>VC <span class="math inline">\alpha</span> DS</li>
</ol>
<p>Let <span class="math inline">G = (V, E), k</span> be an instance of
VC. We will construct an instance <span class="math inline">G&#39; =
(V&#39;, E&#39;), k&#39;</span> of DS such that <span
class="math inline">G</span> has a vertex cover of cardinality <span
class="math inline">\le k</span> <span class="math inline">\iff
G&#39;</span> has a dominating set of cardinality <span
class="math inline">\le k&#39;</span>. For every edge <span
class="math inline">uv \in E</span> let <span
class="math inline">w_{uv}</span> be a new vertex. Let <span
class="math inline">V&#39; = V \cup \{w_{uv} : uv \in E\}</span>, <span
class="math inline">E&#39; = E \cup \{uw_{uv}, w_{uv}v : uv \in
E\}</span> and <span class="math inline">k&#39; = k</span>. <span
class="math inline">G&#39;</span> and <span
class="math inline">k&#39;</span> can be constructed from <span
class="math inline">G, k</span> in polynomial time.</p>
<p><span class="math inline">G</span> has a vertex cover of cardinality
<span class="math inline">\le k</span> <span
class="math inline">\iff</span> <span class="math inline">G&#39;</span>
has a dominating set of cardinality <span class="math inline">\le
k&#39;</span></p>
<p><span class="math inline">\implies</span> Suppose <span
class="math inline">W \subseteq V</span> is a vertex cover of <span
class="math inline">G</span> and <span class="math inline">|W| \le
k</span>. <span class="math inline">W</span> is a dominating set in
<span class="math inline">G&#39;</span>.</p>
<p><span class="math inline">\impliedby</span> Suppose <span
class="math inline">W&#39; \subseteq V&#39;</span> is a dominating set
of <span class="math inline">G&#39;</span> and <span
class="math inline">|W&#39;| \le k&#39; = k</span>. We run the following
procedure:</p>
<ol type="1">
<li><span class="math inline">W \leftarrow W&#39;</span></li>
<li>for every <span class="math inline">uv \in E</span></li>
<li>if <span class="math inline">w_{uv} \in W&#39;</span> then <span
class="math inline">W \leftarrow W \setminus \{w_{uv}\} \cup
\{u\}</span></li>
</ol>
<p>Then <span class="math inline">W \subseteq V</span> is a vertex cover
of <span class="math inline">G</span> and <span class="math inline">|W|
\le |W&#39;| \le k</span></p>
<h3 data-number="1.8.3" id="methods-for-proving-npc"><span
class="header-section-number">1.8.3</span> methods for proving NPC</h3>
<ol type="1">
<li>restriction - we show that our problem contains a known NPC problem
as a special case (TSP problem)</li>
<li>local replacement - the transformation is non-trivial, but
relatively not complicated (DS problem)</li>
<li>component design - as done in proofs for VC, HC</li>
</ol>
<h2 data-number="1.9" id="random-access-machine-ram"><span
class="header-section-number">1.9</span> random access machine
(RAM)</h2>
<p><span class="math inline">\Sigma = \{a_1, \cdots, a_k\}</span> - a
language. RAM has an infinite set of registers <span
class="math inline">R1, R2, \cdots</span>. Each register stores a string
from <span class="math inline">\Sigma^*</span>. There is an infinite set
of line names <span class="math inline">N1, N2, \cdots</span>. There are
7 types of instructions: <span class="math inline">N1</span> - a line
name or nothing, <span class="math inline">RX, RY</span> - registers.
<span class="math inline">N2&#39; \in \{N2a, N2b\}</span> (a - above, b
- below).</p>
<ol type="1">
<li><span class="math inline">N1</span> addj <span
class="math inline">RX</span> – adds aj to the right end of the string
in <span class="math inline">RX</span> (<span class="math inline">1 \le
j \le k</span>)</li>
<li><span class="math inline">N1</span> del <span
class="math inline">RX</span> – deletes the first from left symbol of
the string stored in <span class="math inline">RX</span></li>
<li><span class="math inline">N1</span> clr <span
class="math inline">RX</span> – changes the string in <span
class="math inline">RX</span> into <span
class="math inline">\varepsilon</span></li>
<li><span class="math inline">N1</span> <span class="math inline">RX
\leftarrow RY</span> – copies the string in <span
class="math inline">RY</span> into <span
class="math inline">RX</span></li>
<li><span class="math inline">N1</span> jmp <span
class="math inline">N2&#39;</span> – jumps to the closest instruction
with line name <span class="math inline">N2</span> above if <span
class="math inline">N2&#39; = N2a</span> or below if <span
class="math inline">N2&#39; = N2b</span></li>
<li><span class="math inline">N1</span> <span
class="math inline">RX</span> jmpj <span
class="math inline">N2&#39;</span> – jumps if the first symbol of the
string in <span class="math inline">RX</span> is aj (<span
class="math inline">1 \le j \le k</span>)</li>
<li><span class="math inline">N1</span> continue – does nothing</li>
</ol>
<p>Instructions are executed in order in which they are written except
jumps.</p>
<p>A RAM program is a finite sequence of instructions such that each
jump is executable and the last instruction is continue. A RAM program
halts when it reaches the final continue instruction.</p>
<p>A partial function <span class="math inline">f: N^n \to N</span> is
computable on RAM if there exists a RAM program <span
class="math inline">P</span> such that if it starts in the following
configuration: for <span class="math inline">i = 1, \cdots, n</span>
<span class="math inline">x_i</span> is in <span
class="math inline">R_i</span> and all the other registers are empty
(<span class="math inline">\varepsilon</span>) and:</p>
<ul>
<li><span class="math inline">P</span> halts <span
class="math inline">\iff f(x_1, \cdots, x_n)</span> is defined</li>
<li>if <span class="math inline">P</span> halts then there is <span
class="math inline">f(x_1, \cdots, x_n)</span> in R1 and the other
registers are empty</li>
</ul>
<p>Lemma: Instructions 3,4,5 can be eliminated from the set of
instructions.</p>
<h3 data-number="1.9.1"
id="every-ram-program-can-be-simulated-on-a-tm"><span
class="header-section-number">1.9.1</span> every RAM program can be
simulated on a TM</h3>
<p>Suppose RAM program <span class="math inline">P</span> uses only the
registers <span class="math inline">R1, \cdots, Rm</span>. Before the
execution of <span class="math inline">P</span>, <span
class="math inline">Ri</span> contains string <span
class="math inline">r_i</span> for all <span
class="math inline">i</span>. <span class="math inline">P</span>
consists only of instructions of type 1, 2, 6, or 7. We assume <span
class="math inline">P</span> contains only one instruction of type 7.
Construction of a TM <span class="math inline">M</span> simulating <span
class="math inline">P</span>:</p>
<p>Let <span class="math inline">n</span> be the number of instructions
of <span class="math inline">P</span>. <span
class="math inline">M</span> consists of <span
class="math inline">n</span> blocks - each block corresponds to one
instruction of <span class="math inline">P</span>. Blocks are joined in
a way that the instructions of <span class="math inline">P</span> will
be executed in the same order as in <span class="math inline">P</span>.
On the input <span class="math inline">M</span> has <span
class="math inline">r_1, r_2, \cdots, r_m</span> on the tape (commas are
in the string).</p>
<ol type="1">
<li><span class="math inline">N</span> addi <span
class="math inline">Rj</span> - <span class="math inline">M</span> finds
the end of the string stored in <span class="math inline">Rj</span> in
the tape (<span class="math inline">M</span> finds j-th comma) <span
class="math inline">M</span> writes <span class="math inline">a_i</span>
on the tape and moves all symbols on the right of the head one cell to
the right.</li>
<li><span class="math inline">N</span> del <span
class="math inline">Rj</span> - <span class="math inline">M</span> finds
the string stored in <span class="math inline">Rj</span> on the tape
(<span class="math inline">M</span> finds (j-1)-th comma). <span
class="math inline">M</span> writes <span class="math inline">B</span>
(blank symbol) to the cell observed by the head and moves all symbols on
the right of the head one cell to the left.</li>
<li><span class="math inline">N</span> <span
class="math inline">Rj</span> jmpi <span
class="math inline">N&#39;</span> - <span class="math inline">M</span>
finds the string stored in <span class="math inline">Rj</span> (<span
class="math inline">M</span> finds (j-1)-th comma) checks the first
symbol of this string and goes to proper block</li>
<li><span class="math inline">N</span> continue - <span
class="math inline">M</span> clears the tape except the string stored in
<span class="math inline">R1</span> (because it is the output) (before
th first comma) and halts.</li>
</ol>
<h3 data-number="1.9.2"
id="the-computation-of-any-tm-m-can-be-simulated-on-ram"><span
class="header-section-number">1.9.2</span> The computation of any TM M
can be simulated on RAM</h3>
<p>Let <span class="math inline">M = (Q, \Sigma, \Gamma, \delta, B, q_1,
F)</span>. Let <span class="math inline">Q = \{q_1, \cdots,
q_s\}</span>. Let <span class="math inline">m = |\Gamma| + 1</span>. We
encode the symbols from <span class="math inline">\Gamma</span> with
<span class="math inline">0, 1, \cdots, m-1</span> in a way that <span
class="math inline">B</span> is encoded with <span
class="math inline">0</span> and <span class="math inline">m-1</span> is
the code of a special end of tape symbol. We construct a RAM program
<span class="math inline">P</span> that simulates the computation of
<span class="math inline">M</span>. <span class="math inline">P</span>
will use three registers <span class="math inline">R\text{-}1</span>
(string before the head), <span class="math inline">R0</span> (character
under the head), <span class="math inline">R1</span> (string after the
head). <span class="math inline">b_i</span> is the code of the symbol in
<span class="math inline">i</span>-th cell.</p>
<ul>
<li><span class="math inline">R\text{-}1</span> contains <span
class="math inline">l = b_{k-1} + b_{k-2}m + \cdots +
b_{-1}m^k</span></li>
<li><span class="math inline">R0</span> contains <span
class="math inline">s = b_k</span></li>
<li><span class="math inline">R1</span> contains <span
class="math inline">r = b_{k+1} + b_{k+2}m + \cdots</span> (well defined
because B is encoded with 0)</li>
</ul>
<p>P:</p>
<p>[read input string and initialize the registers]<br />
N1 [moves of <span class="math inline">M</span> from the state <span
class="math inline">q_1</span>]<br />
N2 [moves of <span class="math inline">M</span> from the state <span
class="math inline">q_2</span>]<br />
<span class="math inline">\vdots</span><br />
Ns [moves of <span class="math inline">M</span> from the state <span
class="math inline">q_s</span>]</p>
<p>Each <span class="math inline">Nj</span>:</p>
<pre><code>R0 jmp0 Nj,0b
R0 jmp1 Nj,1b
...
R0 jmpm-2 Nj,m-2b</code></pre>
<p>I give up</p>
</body>
</html>
